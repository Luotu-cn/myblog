(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{232:function(t,a,r){"use strict";r.r(a);var v=r(0),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类","aria-hidden":"true"}},[t._v("#")]),t._v(" 类")]),t._v(" "),r("h4",{attrs:{id:"final类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#final类","aria-hidden":"true"}},[t._v("#")]),t._v(" final类")]),t._v(" "),r("p",[t._v("final类"),r("strong",[t._v("不能被继承")]),t._v("，没有类能够继承final类的任何特性。")]),t._v(" "),r("h4",{attrs:{id:"抽象类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抽象类","aria-hidden":"true"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),r("p",[t._v("抽象类"),r("strong",[t._v("不能用来实例化对象")]),t._v("，声明抽象类的唯一目的是"),r("strong",[t._v("为了将来对该类进行扩充")]),t._v("。\n"),r("strong",[t._v("一个类不能同时被abstract和final修饰")]),t._v("。如果一个类"),r("strong",[t._v("包含抽象方法")]),t._v("，那么该类"),r("strong",[t._v("一定要声明为抽象类")]),t._v("，否则将出现编译错误。"),r("br"),t._v("\n抽象类"),r("strong",[t._v("可以包含抽象方法和非抽象方法")]),t._v("。")]),t._v(" "),r("blockquote",[r("p",[t._v("如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。")])]),t._v(" "),r("p",[r("strong",[t._v("声明抽象方法会造成以下两个结果：")])]),t._v(" "),r("ul",[r("li",[t._v("如果一个类包含抽象方法，那么该类必须是抽象类。")]),t._v(" "),r("li",[t._v("任何子类必须重写父类的抽象方法，或者声明自身为抽象类。")]),t._v(" "),r("li",[t._v("最后必须又子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。")])])])}),[],!1,null,null,null);a.default=_.exports}}]);