(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{238:function(t,a,e){"use strict";e.r(a);var r=e(0),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"java的编译原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java的编译原理","aria-hidden":"true"}},[t._v("#")]),t._v(" Java的编译原理")]),t._v(" "),e("p",[t._v("源代码->词法分析->符号流->语法分析->语法树->语义分析->语法树->中间代码生成->(到此为前端编译)->中间代码->机器无关代码优化->中间代码->代码生成->机器语言->机器相关代码优化->机器语言（此为后端编译）（根据完成任务不同）")]),t._v(" "),e("blockquote",[e("p",[t._v("前端编译主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间代码生成。")])]),t._v(" "),e("blockquote",[e("p",[t._v("后端编译主要指与目标机有关的部分，包括代码优化和目标代码生成等。")])]),t._v(" "),e("h5",{attrs:{id:"词法分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 词法分析")]),t._v(" "),e("p",[t._v("词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。")]),t._v(" "),e("blockquote",[e("p",[t._v("标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类。")])]),t._v(" "),e("h5",{attrs:{id:"语法分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 语法分析")]),t._v(" "),e("p",[t._v("语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。")]),t._v(" "),e("h5",{attrs:{id:"语义分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语义分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 语义分析")]),t._v(" "),e("p",[t._v("语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。")]),t._v(" "),e("blockquote",[e("p",[t._v("一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。")])]),t._v(" "),e("h5",{attrs:{id:"中间代码生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间代码生成","aria-hidden":"true"}},[t._v("#")]),t._v(" 中间代码生成")]),t._v(" "),e("p",[t._v("在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。该中间表示有两个重要的性质： 1.易于生成； 2.能够轻松地翻译为目标机器上的语言。")]),t._v(" "),e("blockquote",[e("p",[t._v("在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。"),e("br"),t._v("\nPS：著名的解语法糖操作，也是在javac中完成的。")])]),t._v(" "),e("h4",{attrs:{id:"java中的后端编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java中的后端编译","aria-hidden":"true"}},[t._v("#")]),t._v(" java中的后端编译")]),t._v(" "),e("p",[t._v("JIT技术：JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。")]),t._v(" "),e("h4",{attrs:{id:"热点检测（热点探测，hot-spot-detection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#热点检测（热点探测，hot-spot-detection","aria-hidden":"true"}},[t._v("#")]),t._v(" 热点检测（热点探测，Hot Spot Detection)")]),t._v(" "),e("ol",[e("li",[t._v("基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。")]),t._v(" "),e("li",[t._v("基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。")])]),t._v(" "),e("blockquote",[e("p",[t._v("HotSpot虚拟机中使用的是第二种，每个方法两个计数器（方法调用计数器和回边计数器）\n"),e("code",[t._v("方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。")]),t._v(" "),e("code",[t._v("回边计数器。是记录方法中的for或者while的运行次数的计数器。")])])]),t._v(" "),e("p",[e("strong",[t._v("JIT除了具有缓存的功能外，还会对代码做各种优化")])]),t._v(" "),e("h6",{attrs:{id:"代码优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码优化")]),t._v(" "),e("p",[t._v("逃逸分析、 锁消除、 锁膨胀、 方法内联、 空值检查消除、 类型检测消除、 公共子表达式消除")])])}),[],!1,null,null,null);a.default=v.exports}}]);